--- a/Source/compositorclient/RPI/Implementation.cpp
+++ b/Source/compositorclient/RPI/Implementation.cpp
@@ -19,6 +19,10 @@
 
 #include "Module.h"
 
+#ifdef VC6
+#define __GBM__
+#endif
+
 #include <EGL/egl.h>
 
 #ifdef VC6
@@ -36,6 +40,8 @@
 #include <virtualinput/virtualinput.h>
 #include "../Client.h"
 
+#include <map>
+
 int g_pipefd[2];
 
 enum inputtype {
@@ -174,7 +180,11 @@
     {
         TRACE_L1(_T("Currently not supported"));
     }
- 
+    //  Wrong type, but keep consistent with the rest
+    bool ScanOut (const EGLSurface & surface) {
+        return _platform.ScanOutRenderTarget (reinterpret_cast <struct gbm_surface *> (surface));
+    }
+
 private:
     ModeSet _platform;
 };
@@ -726,6 +736,7 @@
     uint16_t _touch_state;
 
     mutable uint32_t _refCount;
+    std::map <std::string, IDisplay::ISurface*> _surfaceMap;
 };
 
 Display::DisplayMap Display::_displays;
@@ -839,6 +850,17 @@
 
 int Display::Process(const uint32_t data)
 {
+#ifdef VC6
+// TODO: map data to name
+    IDisplay::ISurface* _surface = SurfaceByName ("");
+
+    if (_surface != nullptr) {
+        /* bool */ Platform::Instance ().ScanOut (_surface->Native ());
+    }
+    else {
+    }
+#endif
+
     Message message;
     if ((data != 0) && (g_pipefd[0] != -1) && (read(g_pipefd[0], &message, sizeof(message)) > 0)) {
         _adminLock.Lock();
@@ -895,10 +917,25 @@
     return (g_pipefd[0]);
 }
 
-Compositor::IDisplay::ISurface* Display::SurfaceByName(const std::string&)
+Compositor::IDisplay::ISurface* Display::SurfaceByName(const std::string& name)
 {
-    //TODO not implemented
-    return nullptr;
+    IDisplay::ISurface* _ret = nullptr;
+
+    if (_surfaceMap.size () > 0) {
+        auto _it =  _surfaceMap.find (name);
+
+        if (_it != _surfaceMap.end ()) {
+            _ret = _it->second;
+        }
+        else {
+// TODO: Asumme the first entry is the correct ones, see Process for missing mapping
+            _ret = _surfaceMap.begin ()->second;
+        }
+    }
+
+    assert (_ret != nullptr);
+
+    return _ret;
 }
 
 Compositor::IDisplay::ISurface* Display::Create(
@@ -907,6 +944,11 @@
     Core::ProxyType<SurfaceImplementation> retval = (Core::ProxyType<SurfaceImplementation>::Create(this, name, width, height));
     Compositor::IDisplay::ISurface* result = &(*retval);
     result->AddRef();
+
+    __attribute__ ((unused)) bool _ret = _surfaceMap.insert (std::pair <std::string, IDisplay::ISurface*> (name, result)).second;
+
+    assert (_ret != false);
+
     return result;
 }
 
--- a/Source/compositorclient/RPI/ModeSet.h
+++ b/Source/compositorclient/RPI/ModeSet.h
@@ -2,6 +2,7 @@
 
 #include <cstdint>
 #include <limits>
+#include <ctime>
 
 #ifdef __cplusplus
 extern "C"
@@ -14,6 +15,10 @@
  
 class ModeSet
 {
+    using gbm_bo_t      = struct gbm_bo*;
+    using gbm_surface_t = struct gbm_surface*;
+    using gbm_device_t  = struct gbm_device*;
+ 
     public:
         ModeSet(const ModeSet&) = delete;
         ModeSet& operator= (const ModeSet&) = delete;
@@ -46,10 +51,37 @@
             return 24;
         }
 
+        static constexpr gbm_device_t gbm_device_t_DEFAULT () {
+            return nullptr;
+        }
+
+        static constexpr gbm_surface_t gbm_surface_t_DEFAULT () {
+            return nullptr;
+        }
+
+        static constexpr gbm_bo_t gbm_bo_t_DEFAULT () {
+            return nullptr;
+        }
+
+        static constexpr uint32_t MinimumBufferCount () {
+            return 1;
+        }
+
+        // TODO match with the window system, numbber of buffers
+        static constexpr uint32_t MaximumBufferCount () {
+            return 2;
+        }
+
+        // Seconds
+        static constexpr time_t FrameDuration () {
+            return 1;
+        }
+
         uint32_t Width() const;
         uint32_t Height() const;
         struct gbm_surface* CreateRenderTarget(const uint32_t width, const uint32_t height);
         void DestroyRenderTarget(struct gbm_surface* surface);
+        bool ScanOutRenderTarget (struct gbm_surface* surface, uint32_t count = MaximumBufferCount ());
 
     private:
         void Create();
--- a/Source/compositorclient/RPI/ModeSet.cpp
+++ b/Source/compositorclient/RPI/ModeSet.cpp
@@ -10,6 +10,8 @@
 #include <unistd.h>
 #include <fcntl.h>
 
+#include <mutex>
+
 extern "C"
 {
 #include <drm/drm_fourcc.h>
@@ -426,3 +428,136 @@
     }
 }
 
+bool ModeSet::ScanOutRenderTarget (struct gbm_surface* surface, uint32_t count) {
+    bool _ret = false;
+
+    static gbm_bo_t _bo;
+
+   _bo = gbm_surface_lock_front_buffer (surface);
+
+    if (_bo != gbm_bo_t_DEFAULT ()) {
+        uint32_t _format = gbm_bo_get_format (_bo);
+        uint32_t _bpp = gbm_bo_get_bpp (_bo);
+        uint32_t _stride = gbm_bo_get_stride (_bo);
+        uint32_t _height = gbm_bo_get_height (_bo);
+        uint32_t _width = gbm_bo_get_width (_bo);
+        uint32_t _handle = gbm_bo_get_handle (_bo).u32;
+
+        assert (_device == gbm_bo_get_device (_bo));
+        assert (_fd == gbm_device_get_fd (_device));
+
+        assert (_format == DRM_FORMAT_XRGB8888 || _format == DRM_FORMAT_ARGB8888);
+        assert (gbm_device_is_format_support (_device, _format, GBM_BO_USE_SCANOUT) != false);
+        assert (_bpp == BPP ());
+        assert (_width == Width ());
+        assert (_height == Height ());
+
+        // Nothing better to initialize it with
+        decltype (_fb) __fb = _fb;
+
+        if (_fd > 0 && drmModeAddFB (_fd, _width, _height, _format != DRM_FORMAT_ARGB8888 ? _bpp - BPP () + ColorDepth () : _bpp, _bpp, _stride, _handle, &_fb) == 0) {
+                    using drm_callback_data_t = struct { int fd; uint32_t fb; gbm_bo_t bo; bool waiting; };
+
+                    static drm_callback_data_t _callback_data = {_fd, __fb, _bo, true};
+
+                    // Guardian of the shared data presented one line earlier
+                    static std::mutex _mutex;
+
+                    _callback_data = {_fd, __fb, _bo, true};
+
+                    int _err = drmModePageFlip (_fd, _crtc, _fb, DRM_MODE_PAGE_FLIP_EVENT, &_callback_data);
+
+                    switch (0 - _err) {
+                        case 0      :   {   // No error
+                                            // Strictly speaking c++ linkage and not C linkage
+                                            // Asynchronous, but never called more than once, waiting in scope
+                                            auto handler = +[] (int fd, unsigned int frame, unsigned int sec, unsigned int usec, void* data) {
+                                                std::lock_guard < decltype (_mutex) > _lock (_mutex);
+
+                                                if (data != nullptr) {
+                                                    drm_callback_data_t* _data = reinterpret_cast <drm_callback_data_t*> (data);
+
+                                                    assert (fd == _data->fd);
+
+
+                                                    // Encourages the loop to break
+                                                    _data->waiting = false;
+                                                }
+                                                else {
+                                                    //TRACE_L1 (_T ("Invalid callback data"));
+                                                    fprintf (stdout, "Invalid callback data\n");
+                                                }
+                                            };
+
+                                            // Use the magic constant here because the struct is versioned!
+                                            drmEventContext _context = { .version = 2, . vblank_handler = nullptr, .page_flip_handler = handler };
+
+                                            fd_set _fds;
+
+                                            struct timespec _timeout = { .tv_sec = FrameDuration (), .tv_nsec = 0 };
+
+                                            bool _waiting = true;
+
+                                            {
+                                                std::lock_guard < decltype (_mutex) > _lock (_mutex);
+                                                _waiting = _callback_data.waiting;
+                                            }
+
+                                            while (_waiting != false) {
+                                                FD_ZERO (&_fds);
+                                                FD_SET( _fd, &_fds);
+
+                                                // Race free
+                                                _err  = pselect(_fd + 1, &_fds, nullptr, nullptr, &_timeout, nullptr);
+
+                                                if (_err < 0) {
+                                                    // Error; break the loop
+                                                    break;
+                                                }
+                                                else {
+                                                    if (_err == 0) {
+                                                            // Timeout; retry
+// TODO: add an additional condition to break the loop to limit the number of retries, but then deal with the asynchronous nature of the callback
+                                                    }
+                                                    else { // ret > 0
+                                                        if (FD_ISSET (_fd, &_fds) != 0) {
+                                                            // Node is readable
+                                                            if (drmHandleEvent (_fd, &_context) != 0) {
+                                                                // Error; break the loop
+                                                                break;
+                                                            }
+
+                                                            // Flip probably occured already otherwise it loops again
+                                                        }
+                                                    }
+                                                }
+
+                                                {
+                                                    std::lock_guard < decltype (_mutex) > _lock (_mutex);
+                                                    _waiting = _callback_data.waiting;
+                                                }
+                                            }
+
+                                            break;
+                                        }
+                        // Many causes, but the most obvious is a busy resource or a missing drmModeSetCrtc
+                        case EINVAL :   {   // Probably a missing drmModeSetCrtc or an invalid _crtc
+                                            // See ModeSet::Create, not recovering here
+                                            assert (false);
+                                            break;
+                                        }
+                        case EBUSY  :
+                        default     :   {
+                                        // There is nothing to be done about it
+                                        }
+                    }
+        }
+
+        // These two should be kept in sync for multiple buffers
+
+        /* void */ gbm_surface_release_buffer (surface, _bo);
+        /* int */ drmModeRmFB(_fd, __fb);
+    }
+
+    return _ret;
+}
